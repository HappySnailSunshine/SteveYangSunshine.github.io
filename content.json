{"pages":[],"posts":[{"title":"Hibernate Validator参数校验","text":"项目中用到的参数校验有很多，这里用Hibernate Validator进行参数校验。 例如，要进行下面的参数校验。 Username length &gt;6 Password &lt; 6 Hibernate validator对javabean（domain model）进行校验 导包Spring-boot-start-web中提供了validator需要的包，不需要额外的导包 组件注册 使用在javabean中直接使用注解 然后即可完成参数校验！","link":"/2019/08/21/Hibernate-Validator参数校验/"},{"title":"Druid监控功能","text":"可以说，druid是目前为止最好的数据库连接池。下面是开启数据库监控功能。 导包druid对springboot的支持（druid包） 配置 使用 将上述配置结合进项目中，即可实现监控功能！","link":"/2019/08/11/Druid监控功能/"},{"title":"Maven中Jdk问题","text":"Maven工程jdk1.5的问题是用idea开发常见的问题，如果不加以配置，以后会一直报错！ Maven的配置文件Config/settings.xml &lt;profiles&gt;标签 Maven工程的配置文件Pom.Xml","link":"/2019/09/21/Maven中Jdk问题/"},{"title":"Maven中Scope作用域","text":"Maven中默认的作用域是compile,测试的时候作用域是Test。 Scope作用域Compile：编译的时候需要并且要打包到应用（lib文件夹）（通常默认的是compile） Provided：编译的时候需要 打包的时候不需要（通常只有servlet是provided） Test：测试；scope为test的依赖只能由Tests目录下的代码使用，sources目录下代码不能使用（通常只有junit4和spring-test这两个依赖scope为test） Runtime：运行，编译的时候不需要，运行的时候需要（通常只有mysql-connector-java的scope为runtime） 使用maven要在网络良好的情况下使用如果jar包没有下载下来 .lastupdated 如果依赖出现问题：去本地仓库检查→根据groupId、artifactId、version对应的文件夹去检查，如果jar包未下载，则清空重新下载 注意（一定注意）当你引入一个其他人的maven工程的时候，首先要检查maven配置是否是自己的 注意点2 Properties标签&lt;properties&gt;同属于project的子标签","link":"/2019/09/27/Maven中Scope作用域/"},{"title":"Maven父子工程","text":"父子工程在平时的时候，很少用。但是最近的一个微服务项目，里面的guns脚手架，其实就是父子工程！ 其中父工程中的pom.xml文件中导入的依赖，在子模块中就没必要再导入。 1234567891011121314&lt;modules&gt; &lt;module&gt;guns-admin&lt;/module&gt; &lt;module&gt;guns-core&lt;/module&gt; &lt;module&gt;guns-rest&lt;/module&gt; &lt;module&gt;guns-generator&lt;/module&gt; &lt;module&gt;guns-film&lt;/module&gt; &lt;module&gt;guns-cinema&lt;/module&gt; &lt;module&gt;guns-user&lt;/module&gt; &lt;module&gt;guns-gateway&lt;/module&gt; &lt;module&gt;guns-api&lt;/module&gt; &lt;module&gt;guns-payment&lt;/module&gt; &lt;module&gt;guns-order&lt;/module&gt; &lt;module&gt;guns-promo&lt;/module&gt;&lt;/modules&gt; 但是父模块中要写上子模块的module，这样的话，子模块才可以使用相关依赖！ 当然，子模块之间是不能耦合的！","link":"/2019/09/14/Maven父子工程/"},{"title":"Mybatis中占位符的区别","text":"动态 sql 是 mybatis 的主要特性之一，在 mapper 中定义的参数传到 xml 中之后，在查询之前 mybatis 会对其进行动态解析。mybatis 为我们提供了两种支持动态 sql 的语法：#{} 以及 ${}。 ${}和#{}${}字符串的拼接不好的 sql注入的风险 若使用${}作为sql语句 #{} 预编译","link":"/2019/10/04/Mybatis中占位符的区别/"},{"title":"Papehelper 分页","text":"分页在项目中比较常用 ，这里是一个Spring中可以用的分页插件。使用起来非常方便，但是必须放在要分页的查询语句周围，才会起作用！ 首先需要导入分页所需要的依赖: 123456&lt;!--分页插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; application.yml中需要写配置项: 1234567891011121314spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/j16_db username: root password: 123456pagehelper: helper-dialect: mysqllogging: level: com: cskaoyan: pagehelper: mapper: debug 其他层正常写,然后services层: 12345678910111213141516171819202122232425262728293031import com.cskaoyan.pagehelper.bean.ListBean;import com.cskaoyan.pagehelper.bean.User;import com.cskaoyan.pagehelper.mapper.UserMapper;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Override public ListBean queryUsers(int start, int limit) { //只需要加下面一句话就可以分页 PageHelper.startPage(start, limit); //如果前端的需求是要根据某一个值,进行排序,按照下面的写,sort里面是根据哪一个值排序,order里面是要写顺序还是逆序排序,bean中的这两个值是需要接受前端数据来获得得! //PageHelper.startPage(steveGoods.getPage(), steveGoods.getLimit(), steveGoods.getSort() + \" \" + steveGoods.getOrder()); List&lt;User&gt; users = userMapper.queryUsers(); PageInfo&lt;User&gt; userPageInfo = new PageInfo&lt;&gt;(users); //下面这句还可以查询出来总数(不用自己另外写sql语句来查询总数) long total = userPageInfo.getTotal(); ListBean&lt;User&gt; userListBean = new ListBean&lt;&gt;(); userListBean.setItems(users); userListBean.setTotal(total); return userListBean; }}","link":"/2019/10/17/Papehelper-分页/"},{"title":"Shiro","text":"基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。 权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。 认证（ren）Subject Credential 授权（shou）Permission 认证是授权的前提 基本模型用户 权限 多对多 通用模型3+2 用户 角色 权限 多对多 多对多 核心组件SecurityManager： Authenticator Authorizer Realm（域）是使用shiro的核心组件，在realm中获取认证和授权信息（来源于数据库） 入门案例案例1使用shiro的认证功能，SE 导包Shiro-core commons-logging junit 代码 最终执行IniRealm的doGetAuthenticationInfo方法这个方法 案例2（自定义的Realm）自定义Realm，自行处理 认证信息 配置自定义的realm（继承AuthorizingRealm） 在ini配置文件中配置SecurityManager使用的realm为自定义的realm 重写AuthorizingRealm中的doGetAuthenticationInfo（认证）和doGetAuthorizationInfo（授权）的方法 当执行鉴权操作时会进入到doGetAuthorizationInfo方法中执行，获得（查询）该用户所拥有的权限 Springboot整合shiro导包Shiro-spring（core、web） 注册组件shiroFilterFactoryBean、SecurityManager、自定义Realm ShiroFilterFactoryBean SecurityManager(安全管理器) 自定义Realm 声明式的配置导包aspectj-weaver @EnableAspectjAutoProxy AuthorizationAttributeSourceAdvisor注册组件 使用在RequestMapping对应的方法上使用注解 整合项目CorsConfig之前做过的部分 自定义的sessionManager 配置给SecurityManager 在自定义realm执行查询 认证通过后可以拿到认证信息","link":"/2019/10/15/Shiro/"},{"title":"SpringBoot 跨域配置","text":"​ 当它请求的一个资源是从一个与它本身提供的第一个资源的不同的域名时，一个资源会发起一个跨域HTTP请求(Cross-site HTTP request)。 ​ 比如说，域名A ( http://domaina.example ) 的某 Web 应用程序中通过&lt; img&gt;标签引入了域名B( http://domainb.foo ) 站点的某图片资源(http://domainb.foo/image.jpg)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。​ 在当今的 Web 开发中，使用跨站 HTTP 请求加载各类资源（包括CSS、图片、JavaScript 脚本以及其它类资源），已经成为了一种普遍且流行的方式。正如大家所知，出于安全考虑，浏览器会限制脚本中发起的跨站请求。比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。为了能开发出更强大、更丰富、更安全的Web应用程序，开发人员渴望着在不丢失安全的前提下，Web 应用技术能越来越强大、越来越丰富。比如，可以使用 XMLHttpRequest发起跨站 HTTP 请求。 ​ （这段描述跨域不准确，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从HTTPS的域跨域访问HTTP，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。） ​ 资料来自互联网: https://www.cnblogs.com/csguo/p/9597791.html 项目中用到的跨域: 1234567891011121314151617181920212223import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(\"*\"); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(\"*\"); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(\"*\"); // 3 设置访问源请求方法 return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", buildConfig()); // 4 对接口配置跨域设置 return new CorsFilter(source); }} ​","link":"/2019/10/21/SpringBoot-跨域配置/"},{"title":"Springboot文件上传","text":"对象存储oss可以提高页面访问速度，将静态资源放到云端，这里是放到阿里云。 默认注册了multipartResolver这个组件，可以直接去使用 我们可以将文件上传到指定目录，并且将该指定目录配置为静态资源目录 使用阿里云oss存储图片等静态资源，首先需要配置一些参数！ 12345678mall: aliyun: access-key-id: LTAI4Fr5gfYhcVjLMqeRGbuT access-secret: IrkcHu6dZyrjPZRushgO76P5392HJ1 url: https://cskaoyan.oss-cn-beijing.aliyuncs.com/ oss: bucket: cskaoyan end-point: oss-cn-beijing.aliyuncs.com 然后进文件长传的细节写入工具类中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.aliyun.oss.OSSClient;import com.aliyun.oss.model.PutObjectRequest;import com.cskaoyan.mall.bean.Storage;import com.cskaoyan.mall.config.AliyunConfig;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import org.springframework.util.ResourceUtils;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.UUID;@Controllerpublic class FileUpload { public static Storage uploadToAliyun(AliyunConfig aliyunConfig,MultipartFile file) throws IOException { InputStream inputStream = file.getInputStream(); String accessKeyId = aliyunConfig.getAccessKeyId(); String accessSecret = aliyunConfig.getAccessSecret(); String bucket = aliyunConfig.getOssConfig().getBucket(); String endPoint = aliyunConfig.getOssConfig().getEndPoint(); OSSClient ossClient = new OSSClient(endPoint, accessKeyId, accessSecret); String uuid = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); String key = uuid + \".jpg\"; ossClient.putObject(new PutObjectRequest(bucket,key, inputStream)); String requestURL = aliyunConfig.getUrl()+key; Storage storage = getStorage(file, requestURL, key); return storage; } private static Storage getStorage(MultipartFile file,String requestURL,String key){ Storage storage = new Storage(); storage.setKey(key); storage.setUrl(requestURL); storage.setType(file.getContentType()); storage.setSize((int)file.getSize()); storage.setName(file.getOriginalFilename()); Date date = new Date(); storage.setAddTime(date); storage.setUpdateTime(date); return storage; } public static Storage uploadToLocation(MultipartFile file, String filePath,HttpServletRequest request) throws IOException { String url=\"/wx/storage/fetch/\"; String key = UUID.randomUUID().toString()+\".jpg\"; File file1 = new File(filePath+url+key); if(!file1.exists()){ file1.mkdirs(); } file.transferTo(file1); String requestURL = request.getRequestURL().toString(); String requestURI = request.getRequestURI(); requestURL = requestURL.replace(requestURI,\"\"); requestURL = requestURL+url+key; Storage storage = getStorage(file, requestURL, key); return storage; }} 然后再controler层调用对应的方法即可！ 123456789101112131415161718192021@RequestMapping(\"/wx/storage/upload\")public BaseRespVo upload(HttpServletRequest request) throws IOException { MultipartHttpServletRequest req =(MultipartHttpServletRequest)request; MultipartFile file = req.getFile(\"file\"); Storage storage = FileUpload.uploadToAliyun(aliyunConfig,file); //Storage storage = FileUpload.uploadToLocation(file,filePath, request); BaseRespVo insert = storageService.insert(storage); return insert;}@RequestMapping(\"/admin/storage/create\")@RequiresPermissions(\"admin:storage:create\")public BaseRespVo create(MultipartFile file) throws IOException { Storage storage = FileUpload.uploadToAliyun(aliyunConfig,file); BaseRespVo insert = storageService.insert(storage); return insert;}","link":"/2019/08/27/Springboot文件上传/"},{"title":"IDEA Keymap","text":"IDEA 快捷键 在使用IntelliJ Idea的时候，使用快捷键是必不可少的。掌握一些常用的快捷键能大大提高我们的开发效率。有些快捷键可以熟练的使用，但是还有另外一些快捷键虽然很好用，但是由于因为没有形成使用习惯或者没有理解快捷键的用法，甚至之前对一些快捷键根本没有概念，导致不会去使用。对于这些快捷键，如果能够用好，编辑代码的效率必能提高一个水平。所以在此梳理出来，加强自己的使用，形成习惯。 （注：有些操作的快捷键做了更改，和IntelliJ Idea默认的快捷键不一样） —————Edit————— —————-Find—————– ————–Navigate————— 这里的快捷键用的频率还是很高的，但是之前用的最多的是Ctrl+F和Ctrl+Shift+F，后面相关的Find Usages基本上没有用过，后面应该多使用，有的时候相对Ctrl+F在文件内按字符串查找，还是更好用一些 目前还不知道Previous Occurrence 和 Next Occurrence是怎么用的，在变量上使用没有反应。不过在Edit–Find菜单下有几个菜单项：Find Next / Move to Next Occurrence、Find Previous / Move to Previous Occurrence等。当选中变量的时候，需要首先点击“Find Word at Caret”，然后再点击上述选项才有用 ———————-Code—————— —————————————–Completion—————————————— ——————-Folding—————— ——————————— ——————————— ————————————-Refactor——————————————– 啊 下面的部分是另一个帖子里面的实用快捷键:Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl+D 复制行Ctrl+X 删除行快速修复 alt+enter(modify/cast)代码提示 alt+/ctr+G 定位某一行Shift+F6 重构-重命名 IDEA 批量修改变量名 点击变量名后按shift+F6Ctrl+R 替换文本Ctrl+F 查找文本 代码处F2 快速定位编译出错位置 Ctrl+E 最近打开的文件Ctrl+J 自动代码 Ctrl+ home/end 抵达文件头部,底部 组织导入 ctr+alt+O格式化代码 ctr+alt+L大小写转化 ctr+shift+U IntelliJ Idea 常用快捷键列表Alt+回车导入包,自动修正Ctrl+N 查找类Ctrl+Shift+N 查找文件Ctrl+Alt+L 格式化代码 Ctrl+Alt+O 优化导入的类和包Alt+Insert 生成代码(如get,set方法,构造函数等)Ctrl+E或者Alt+Shift+C 最近更改的代码Ctrl+R 替换文本 Ctrl+F 查找文本Ctrl+Shift+Space 自动补全代码Ctrl+空格代码提示 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Shift+F6 重构-重命名Ctrl+Shift+先上键Ctrl+X 删除行Ctrl+D 复制行Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl+J 自动代码Ctrl+E 最近打开的文件 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档Alt+F1 查找代码所在位置Alt+1 快速打开或隐藏工程面板 Ctrl+Alt+left/right 返回至上次浏览的位置Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Ctrl+Shift+Up/Down代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码，连续按会有其他效果 选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 Ctrl+O 查看该类可以重写哪些方法 查询快捷键CTRL+N 查找类CTRL+SHIFT+N 查找文件CTRL+SHIFT+ALT+N 查找类中的方法或变量CIRL+B 找变量的来源CTRL+ALT+B 找所有的子类CTRL+SHIFT+B 找变量的类CTRL+G 定位行CTRL+F 在当前窗口查找文本CTRL+SHIFT+F 在指定窗口查找文本CTRL+R 在当前窗口替换文本CTRL+SHIFT+R 在指定窗口替换文本ALT+SHIFT+C 查找修改的文件CTRL+E 最近打开的文件F3 向下查找关键字出现位置SHIFT+F3 向上一个关键字出现位置F4 查找变量来源CTRL+ALT+F7 选中的字符查找工程出现的地方CTRL+SHIFT+O 弹出显示查找内容 自动代码ALT+回车 导入包,自动修正CTRL+ALT+L 格式化代码CTRL+ALT+I 自动缩进CTRL+ALT+O 优化导入的类和包ALT+INSERT 生成代码(如GET,SET方法,构造函数等)CTRL+E 最近更改的代码CTRL+SHIFT+SPACE 自动补全代码CTRL+空格 代码提示CTRL+ALT+SPACE 类名或接口名提示CTRL+P 方法参数提示CTRL+J 自动代码CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{}里 还可以将语句加到try…catch语句中 CTRL+ALT+M 抽取方法 Ctrl + Alt + V 假如输入,shiro权限管理相关: 1return new ShiroFilterFactoryBean(); 按了快捷键以后: 12ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();return shiroFilterFactoryBean; 复制快捷方式CTRL+D 复制行CTRL+X 剪切,删除行 其他快捷方式CIRL+U 大小写切换CTRL+Z 倒退CTRL+SHIFT+Z 向前CTRL+ALT+F12 资源管理器打开文件夹ALT+F1 查找文件所在目录位置SHIFT+ALT+INSERT 竖编辑模式CTRL+/ 注释//CTRL+SHIFT+/ 注释/…/CTRL+W 选中代码，连续按会有其他效果CTRL+B 快速打开光标处的类或方法ALT+ ←/→ 切换代码视图CTRL+ALT ←/→ 返回上次编辑的位置ALT+ ↑/↓ 在方法间快速移动定位SHIFT+F6 重构-重命名CTRL+H 显示类结构图CTRL+Q 显示注释文档ALT+1 快速打开或隐藏工程面板CTRL+SHIFT+UP/DOWN 代码向上/下移动。CTRL+UP/DOWN 光标跳转到第一行或最后一行下ESC 光标返回编辑框SHIFT+ESC 光标返回编辑框,关闭无用的窗口F1 帮助千万别按,很卡!书签帮助L(操作非数字键盘的数字!!!!!!!) Ctrl +Shift+1-9 书签定位行为1-9 或者字母, Ctrl + 1-9 自动跳转到锁定位的书签位置 Ctrl+ F9 重新编译, 删除缓存.实时更新 Ctrl+Shift+U 大小写切换","link":"/2019/07/01/Steve/"},{"title":"Maven常见命令","text":"Maven中常见命令，在项目中使用较多,要熟练掌握！ Web项目基本知识 项目构建过程 Clean：清理后续所有过程产生的文件 Compile：编译，不仅仅是class、同时包含将resources所对应的文件放到classes目录下 Test：单元测试、（Tests测试目录）所有的单元测试执行一遍、也会输出一个单元测试的报告 Package：将文件打包成jar或者war 依赖管理对jar包的版本进行统一的管理 Maven工程配置文件：pom.xml (项目的根目录下) Maven的安装及使用下载压缩包解压配置环境变量MAVEN_HOME:包含bin文件夹的目录 Path：%MAVEN_HOME%/bin JAVA_HOME 输入mvn –v的时候出现版本号，意味着安装完成 Maven配置指定本地仓库 远程仓库要注意的点：要在mirrors标签里配置mirror标签，推荐大家使用阿里云的镜像（远程仓库） Maven工程的目录结构--src --main 开发部署的代码配置文件等文件 --java 放的是代码 --resources 配置文件及资源文件 --webapp web项目的根目录 --test 单元测试相关的文件 --java 放的是测试代码 --resources 测试配置文件及资源文件（可以不要，可以使用main下的配置文件） --pom.xml maven的配置文件 --target 文件夹，项目构建相关流程产生的文件，都放在这个目录下 Maven命令mvn compile编译：将java和resources目录下的代码和文件编译，编译到target/classes目录下 mvn clean后续所有构建过程产生的文件都会被清理（删除）掉、target文件夹都会被删除掉 mvn test执行单元测试，src\\test\\java所有包含@Test注解的方法 如果单元测试执行失败不会执行后续的操作 执行失败原因：类名，包含Test mvn package执行打包：默认打包成jar包，文件名artifactId+version+打包类型 配置文件修改打包类型&lt;packaging&gt;war 要求：maven 写packaging=war mvn install将我们的项目安装到本地仓库 idea中使用maven","link":"/2019/07/08/maven常见命令/"},{"title":"TypeHander","text":"TypeHandler,类型转换器,在mybatis中用于实现java类型和JDBC类型的相互转换。 string string[]这个解决的问题是: 数据库存储的是,放json的string,而bean中放的是string[],要实现这两者之间的转换! 分为两种,第一种将Javabean中的数组string[]数据,转换成数据库接受的类型string ​ 第二种将数据库中的json数据string,查出来,转换成Javabean中的string[]类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.MappedTypes;import org.apache.ibatis.type.TypeHandler;import java.io.IOException;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;@MappedTypes(String[].class)public class TransferStringArrayHandler implements TypeHandler&lt;String[]&gt; { ObjectMapper objectMapper = new ObjectMapper(); /*插入数据 由javabean转换为数据库接收的类型*/ @Override public void setParameter(PreparedStatement preparedStatement, int index, String[] strings, JdbcType jdbcType) throws SQLException { try { String jsonArray = objectMapper.writeValueAsString(strings); preparedStatement.setString(index,jsonArray); } catch (JsonProcessingException e) { e.printStackTrace(); } } //由数据中查询出的结果转换成javabean中的类型 @Override public String[] getResult(ResultSet resultSet, String parameterName) throws SQLException { String value = resultSet.getString(parameterName); return parseString2StringArray(value); } private String[] parseString2StringArray(String value) { String[] strings = new String[0]; if (value == null){ return strings; } try { strings = objectMapper.readValue(value, String[].class); } catch (IOException e) { e.printStackTrace(); } return strings; } @Override public String[] getResult(ResultSet resultSet, int index) throws SQLException { String value = resultSet.getString(index); return parseString2StringArray(value); } @Override public String[] getResult(CallableStatement callableStatement, int index) throws SQLException { String value = callableStatement.getString(index); return parseString2StringArray(value); }} user user.detail查出来数据,自动查出来detail 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import com.cskaoyan.bean.UserDetail;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.MappedTypes;import org.apache.ibatis.type.TypeHandler;import java.io.IOException;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;@MappedTypes(UserDetail.class)public class TransferUserDetailHandler implements TypeHandler&lt;UserDetail&gt; { ObjectMapper objectMapper = new ObjectMapper(); @Override public void setParameter(PreparedStatement preparedStatement, int i, UserDetail userDetail, JdbcType jdbcType) throws SQLException { String s = null; try { s = objectMapper.writeValueAsString(userDetail); } catch (JsonProcessingException e) { e.printStackTrace(); } preparedStatement.setString(i,s); } @Override public UserDetail getResult(ResultSet resultSet, String s) throws SQLException { String string = resultSet.getString(s); return parseString2UserDetail(string); } private UserDetail parseString2UserDetail(String string) { UserDetail userDetail = null; if (string == null) return userDetail; try { userDetail = objectMapper.readValue(string, UserDetail.class); } catch (IOException e) { e.printStackTrace(); } return userDetail; } @Override public UserDetail getResult(ResultSet resultSet, int i) throws SQLException { String string = resultSet.getString(i); return parseString2UserDetail(string); } @Override public UserDetail getResult(CallableStatement callableStatement, int i) throws SQLException { String string = callableStatement.getString(i); return parseString2UserDetail(string); } /*插入数据 由javabean转换为数据库接收的类型*/} #","link":"/2019/10/29/TypeHander/"},{"title":"常用设计模式","text":"设计模式设计模式在了解很多优秀的源码中起到很重要的作用。比如优秀的Spring源码等，里面有很多设计模式的使用。在常用的23种设计模式中，这了列举几种更常用的设计模式。 基本原则S 单一职责singleO 开闭原则open对新增开放 对修改封闭 L 里氏替代原则I 接口隔离原则 isolationD 依赖倒置 dependUser user = new User（）； 单例单例模式常见应用场景：–Windows的Task Manager（任务管理器）就是很典型的单例模式 –windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 –项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。 –网站的计数器，一般也是采用单例模式实现，否则难以同步。 –应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 –数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 –操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 –Application 也是单例的典型应用（Servlet编程中会涉及到） –在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理 –在servlet编程中，每个Servlet也是单例 –在spring MVC框架/struts1框架中，控制器对象也是单例 单例模式的特点:1、单例类只能有一个实例。2、单例类必须自己创建自己的唯一实例。构造方法私有**3、单例类必须给所有其他对象提供这一实例。 全局只包含一个自己的实例 特点 线程不安全的懒加载有可能两个线程同时调用,就会是两个对象,所以线程不安全! 123456789101112131415public class Singleton1 { //1、单例类只能有一个实例。 static Singleton1 singleton1; //2、单例类必须自己创建自己的唯一实例。→构造方法私有 private Singleton1(){ } //3、单例类必须给所有其他对象提供这一实例。 public static Singleton1 getSingleton(){ if (singleton1 == null) { singleton1 = new Singleton1(); } return singleton1; }} 线程安全的懒加载 123456789101112131415public class Singleton2 { //1、单例类只能有一个实例。 static Singleton2 singleton2; //2、单例类必须自己创建自己的唯一实例。→构造方法私有 private Singleton2(){ } //3、单例类必须给所有其他对象提供这一实例。 public synchronized static Singleton2 getSingleton(){ if (singleton2 == null) { singleton2 = new Singleton2(); } return singleton2; }} 1234567891011public class Singleton3 { //1、单例类只能有一个实例。 static Singleton3 singleton3 = new Singleton3(); //2、单例类必须自己创建自己的唯一实例。→构造方法私有 private Singleton3(){ } //3、单例类必须给所有其他对象提供这一实例。 public static Singleton3 getSingleton(){ return singleton3; }} 线程安全的立即加载 线程安全懒加载（内部类的实现）内部类 public class Singleton4 { //2、单例类必须自己创建自己的唯一实例。→构造方法私有 private Singleton4(){} //3、单例类必须给所有其他对象提供这一实例。 public static Singleton4 getSingleton(){ System.out.println(“outer getSingleton”); return Inner.getInstance(); } 12345678910111213141516171819202122public class Singleton4 { //2、单例类必须自己创建自己的唯一实例。→构造方法私有 private Singleton4(){} //3、单例类必须给所有其他对象提供这一实例。 public static Singleton4 getSingleton(){ System.out.println(\"outer getSingleton\"); return Inner.getInstance(); } static class Inner{ //1、单例类只能有一个实例。 static Singleton4 singleton4 = new Singleton4(); /*static { singleton4 = new Singleton4(); System.out.println(\"inner static\"); }*/ public static Singleton4 getInstance() { System.out.println(\"inner getInstance\"); return singleton4; } } 工厂通过在工厂中实现实例的创建逻辑，对外隐藏实例的创建过程 简单工厂通过给定的参数的不同，返回不同的实例 当我们去新增新的实例的时候，需要修改代码（和开闭原则有些许出入） 工厂方法更加具体的工厂 建造者Builder侧重点：参数的设置 造人→头 arm leg -–iq 150 -–胳膊180 -–腿 140 代理静态代理 动态代理生成代理对象 Jdk的动态代理：接口的接口的实现 Cglib动态代理 以后用maven就不需要导入jar包啦,只需要自己在pom.xml里面写依赖,然后他,自己就可以导入依赖啦! 还有,以后依赖也不用自己写,直接在Maven仓库查出来 https://mvnrepository.com/artifact 将下面的maven粘贴上就好! 还要注意的是,相应的依赖版本太新,不然不能用!会出现time zone异常,好像是区域不合适! 还有需要注意的是,配置文件必须要写在resources下面!","link":"/2019/08/04/设计模式/"}],"tags":[{"name":"参数校验","slug":"参数校验","link":"/tags/参数校验/"},{"name":"连接池","slug":"连接池","link":"/tags/连接池/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"权限管理","slug":"权限管理","link":"/tags/权限管理/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"}],"categories":[]}
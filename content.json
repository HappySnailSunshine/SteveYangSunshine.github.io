{"pages":[],"posts":[{"title":"Papehelper 分页","text":"分页在项目中比较常用 ，这里是一个Spring中可以用的分页插件。使用起来非常方便，但是必须放在要分页的查询语句周围，才会起作用！ 首先需要导入分页所需要的依赖: 123456&lt;!--分页插件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; application.yml中需要写配置项: 1234567891011121314spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/j16_db username: root password: 123456pagehelper: helper-dialect: mysqllogging: level: com: cskaoyan: pagehelper: mapper: debug 其他层正常写,然后services层: 12345678910111213141516171819202122232425262728293031import com.cskaoyan.pagehelper.bean.ListBean;import com.cskaoyan.pagehelper.bean.User;import com.cskaoyan.pagehelper.mapper.UserMapper;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Override public ListBean queryUsers(int start, int limit) { //只需要加下面一句话就可以分页 PageHelper.startPage(start, limit); //如果前端的需求是要根据某一个值,进行排序,按照下面的写,sort里面是根据哪一个值排序,order里面是要写顺序还是逆序排序,bean中的这两个值是需要接受前端数据来获得得! //PageHelper.startPage(steveGoods.getPage(), steveGoods.getLimit(), steveGoods.getSort() + \" \" + steveGoods.getOrder()); List&lt;User&gt; users = userMapper.queryUsers(); PageInfo&lt;User&gt; userPageInfo = new PageInfo&lt;&gt;(users); //下面这句还可以查询出来总数(不用自己另外写sql语句来查询总数) long total = userPageInfo.getTotal(); ListBean&lt;User&gt; userListBean = new ListBean&lt;&gt;(); userListBean.setItems(users); userListBean.setTotal(total); return userListBean; }}","link":"/2019/08/07/Papehelper-分页/"},{"title":"Shiro","text":"认证（ren）Subject Credential 授权（shou）Permission 认证是授权的前提 基本模型用户 权限 多对多 通用模型3+2 用户 角色 权限 多对多 多对多 核心组件SecurityManager： Authenticator Authorizer Realm（域）是使用shiro的核心组件，在realm中获取认证和授权信息（来源于数据库） 入门案例案例1使用shiro的认证功能，SE 导包Shiro-core commons-logging junit 代码 最终执行IniRealm的doGetAuthenticationInfo方法这个方法 案例2（自定义的Realm）自定义Realm，自行处理 认证信息 配置自定义的realm（继承AuthorizingRealm） 在ini配置文件中配置SecurityManager使用的realm为自定义的realm 重写AuthorizingRealm中的doGetAuthenticationInfo（认证）和doGetAuthorizationInfo（授权）的方法 当执行鉴权操作时会进入到doGetAuthorizationInfo方法中执行，获得（查询）该用户所拥有的权限 Springboot整合shiro导包Shiro-spring（core、web） 注册组件shiroFilterFactoryBean、SecurityManager、自定义Realm ShiroFilterFactoryBean SecurityManager(安全管理器) 自定义Realm 声明式的配置导包aspectj-weaver @EnableAspectjAutoProxy AuthorizationAttributeSourceAdvisor注册组件 使用在RequestMapping对应的方法上使用注解 整合商城项目CorsConfig之前做过的部分 自定义的sessionManager 配置给SecurityManager 在自定义realm执行查询 认证通过后可以拿到认证信息","link":"/2019/06/07/Shiro/"},{"title":"SpringBoot 跨域配置","text":"​ 当它请求的一个资源是从一个与它本身提供的第一个资源的不同的域名时，一个资源会发起一个跨域HTTP请求(Cross-site HTTP request)。 ​ 比如说，域名A ( http://domaina.example ) 的某 Web 应用程序中通过&lt; img&gt;标签引入了域名B( http://domainb.foo ) 站点的某图片资源(http://domainb.foo/image.jpg)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。​ 在当今的 Web 开发中，使用跨站 HTTP 请求加载各类资源（包括CSS、图片、JavaScript 脚本以及其它类资源），已经成为了一种普遍且流行的方式。正如大家所知，出于安全考虑，浏览器会限制脚本中发起的跨站请求。比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。为了能开发出更强大、更丰富、更安全的Web应用程序，开发人员渴望着在不丢失安全的前提下，Web 应用技术能越来越强大、越来越丰富。比如，可以使用 XMLHttpRequest发起跨站 HTTP 请求。 ​ （这段描述跨域不准确，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从HTTPS的域跨域访问HTTP，比如Chrome和Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。） ​ 资料来自互联网: https://www.cnblogs.com/csguo/p/9597791.html 项目中用到的跨域: 1234567891011121314151617181920212223import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(\"*\"); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(\"*\"); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(\"*\"); // 3 设置访问源请求方法 return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", buildConfig()); // 4 对接口配置跨域设置 return new CorsFilter(source); }} ​","link":"/2019/08/04/SpringBoot-跨域配置/"},{"title":"IDEA Keymap","text":"IDEA 快捷键 在使用IntelliJ Idea的时候，使用快捷键是必不可少的。掌握一些常用的快捷键能大大提高我们的开发效率。有些快捷键可以熟练的使用，但是还有另外一些快捷键虽然很好用，但是由于因为没有形成使用习惯或者没有理解快捷键的用法，甚至之前对一些快捷键根本没有概念，导致不会去使用。对于这些快捷键，如果能够用好，编辑代码的效率必能提高一个水平。所以在此梳理出来，加强自己的使用，形成习惯。 （注：有些操作的快捷键做了更改，和IntelliJ Idea默认的快捷键不一样） —————Edit————— —————-Find—————– ————–Navigate————— 这里的快捷键用的频率还是很高的，但是之前用的最多的是Ctrl+F和Ctrl+Shift+F，后面相关的Find Usages基本上没有用过，后面应该多使用，有的时候相对Ctrl+F在文件内按字符串查找，还是更好用一些 目前还不知道Previous Occurrence 和 Next Occurrence是怎么用的，在变量上使用没有反应。不过在Edit–Find菜单下有几个菜单项：Find Next / Move to Next Occurrence、Find Previous / Move to Previous Occurrence等。当选中变量的时候，需要首先点击“Find Word at Caret”，然后再点击上述选项才有用 ———————-Code—————— —————————————–Completion—————————————— ——————-Folding—————— ——————————— ——————————— ————————————-Refactor——————————————– 啊 下面的部分是另一个帖子里面的实用快捷键:Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl+D 复制行Ctrl+X 删除行快速修复 alt+enter(modify/cast)代码提示 alt+/ctr+G 定位某一行Shift+F6 重构-重命名 IDEA 批量修改变量名 点击变量名后按shift+F6Ctrl+R 替换文本Ctrl+F 查找文本 代码处F2 快速定位编译出错位置 Ctrl+E 最近打开的文件Ctrl+J 自动代码 Ctrl+ home/end 抵达文件头部,底部 组织导入 ctr+alt+O格式化代码 ctr+alt+L大小写转化 ctr+shift+U IntelliJ Idea 常用快捷键列表Alt+回车导入包,自动修正Ctrl+N 查找类Ctrl+Shift+N 查找文件Ctrl+Alt+L 格式化代码 Ctrl+Alt+O 优化导入的类和包Alt+Insert 生成代码(如get,set方法,构造函数等)Ctrl+E或者Alt+Shift+C 最近更改的代码Ctrl+R 替换文本 Ctrl+F 查找文本Ctrl+Shift+Space 自动补全代码Ctrl+空格代码提示 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Shift+F6 重构-重命名Ctrl+Shift+先上键Ctrl+X 删除行Ctrl+D 复制行Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl+J 自动代码Ctrl+E 最近打开的文件 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档Alt+F1 查找代码所在位置Alt+1 快速打开或隐藏工程面板 Ctrl+Alt+left/right 返回至上次浏览的位置Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Ctrl+Shift+Up/Down代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码，连续按会有其他效果 选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 Ctrl+O 查看该类可以重写哪些方法 查询快捷键CTRL+N 查找类CTRL+SHIFT+N 查找文件CTRL+SHIFT+ALT+N 查找类中的方法或变量CIRL+B 找变量的来源CTRL+ALT+B 找所有的子类CTRL+SHIFT+B 找变量的类CTRL+G 定位行CTRL+F 在当前窗口查找文本CTRL+SHIFT+F 在指定窗口查找文本CTRL+R 在当前窗口替换文本CTRL+SHIFT+R 在指定窗口替换文本ALT+SHIFT+C 查找修改的文件CTRL+E 最近打开的文件F3 向下查找关键字出现位置SHIFT+F3 向上一个关键字出现位置F4 查找变量来源CTRL+ALT+F7 选中的字符查找工程出现的地方CTRL+SHIFT+O 弹出显示查找内容 自动代码ALT+回车 导入包,自动修正CTRL+ALT+L 格式化代码CTRL+ALT+I 自动缩进CTRL+ALT+O 优化导入的类和包ALT+INSERT 生成代码(如GET,SET方法,构造函数等)CTRL+E 最近更改的代码CTRL+SHIFT+SPACE 自动补全代码CTRL+空格 代码提示CTRL+ALT+SPACE 类名或接口名提示CTRL+P 方法参数提示CTRL+J 自动代码CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{}里 还可以将语句加到try…catch语句中 CTRL+ALT+M 抽取方法 Ctrl + Alt + V 假如输入,shiro权限管理相关: 1return new ShiroFilterFactoryBean(); 按了快捷键以后: 12ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();return shiroFilterFactoryBean; 复制快捷方式CTRL+D 复制行CTRL+X 剪切,删除行 其他快捷方式CIRL+U 大小写切换CTRL+Z 倒退CTRL+SHIFT+Z 向前CTRL+ALT+F12 资源管理器打开文件夹ALT+F1 查找文件所在目录位置SHIFT+ALT+INSERT 竖编辑模式CTRL+/ 注释//CTRL+SHIFT+/ 注释/…/CTRL+W 选中代码，连续按会有其他效果CTRL+B 快速打开光标处的类或方法ALT+ ←/→ 切换代码视图CTRL+ALT ←/→ 返回上次编辑的位置ALT+ ↑/↓ 在方法间快速移动定位SHIFT+F6 重构-重命名CTRL+H 显示类结构图CTRL+Q 显示注释文档ALT+1 快速打开或隐藏工程面板CTRL+SHIFT+UP/DOWN 代码向上/下移动。CTRL+UP/DOWN 光标跳转到第一行或最后一行下ESC 光标返回编辑框SHIFT+ESC 光标返回编辑框,关闭无用的窗口F1 帮助千万别按,很卡!书签帮助L(操作非数字键盘的数字!!!!!!!) Ctrl +Shift+1-9 书签定位行为1-9 或者字母, Ctrl + 1-9 自动跳转到锁定位的书签位置 Ctrl+ F9 重新编译, 删除缓存.实时更新 Ctrl+Shift+U 大小写切换","link":"/2019/10/06/Steve/"},{"title":"TypeHander","text":"string string[]这个解决的问题是: 数据库存储的是,放json的string,而bean中放的是string[],要实现这两者之间的转换! 分为两种,第一种将Javabean中的数组string[]数据,转换成数据库接受的类型string ​ 第二种将数据库中的json数据string,查出来,转换成Javabean中的string[]类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.MappedTypes;import org.apache.ibatis.type.TypeHandler;import java.io.IOException;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;@MappedTypes(String[].class)public class TransferStringArrayHandler implements TypeHandler&lt;String[]&gt; { ObjectMapper objectMapper = new ObjectMapper(); /*插入数据 由javabean转换为数据库接收的类型*/ @Override public void setParameter(PreparedStatement preparedStatement, int index, String[] strings, JdbcType jdbcType) throws SQLException { try { String jsonArray = objectMapper.writeValueAsString(strings); preparedStatement.setString(index,jsonArray); } catch (JsonProcessingException e) { e.printStackTrace(); } } //由数据中查询出的结果转换成javabean中的类型 @Override public String[] getResult(ResultSet resultSet, String parameterName) throws SQLException { String value = resultSet.getString(parameterName); return parseString2StringArray(value); } private String[] parseString2StringArray(String value) { String[] strings = new String[0]; if (value == null){ return strings; } try { strings = objectMapper.readValue(value, String[].class); } catch (IOException e) { e.printStackTrace(); } return strings; } @Override public String[] getResult(ResultSet resultSet, int index) throws SQLException { String value = resultSet.getString(index); return parseString2StringArray(value); } @Override public String[] getResult(CallableStatement callableStatement, int index) throws SQLException { String value = callableStatement.getString(index); return parseString2StringArray(value); }} user user.detail查出来数据,自动查出来detail 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import com.cskaoyan.bean.UserDetail;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.MappedTypes;import org.apache.ibatis.type.TypeHandler;import java.io.IOException;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;@MappedTypes(UserDetail.class)public class TransferUserDetailHandler implements TypeHandler&lt;UserDetail&gt; { ObjectMapper objectMapper = new ObjectMapper(); @Override public void setParameter(PreparedStatement preparedStatement, int i, UserDetail userDetail, JdbcType jdbcType) throws SQLException { String s = null; try { s = objectMapper.writeValueAsString(userDetail); } catch (JsonProcessingException e) { e.printStackTrace(); } preparedStatement.setString(i,s); } @Override public UserDetail getResult(ResultSet resultSet, String s) throws SQLException { String string = resultSet.getString(s); return parseString2UserDetail(string); } private UserDetail parseString2UserDetail(String string) { UserDetail userDetail = null; if (string == null) return userDetail; try { userDetail = objectMapper.readValue(string, UserDetail.class); } catch (IOException e) { e.printStackTrace(); } return userDetail; } @Override public UserDetail getResult(ResultSet resultSet, int i) throws SQLException { String string = resultSet.getString(i); return parseString2UserDetail(string); } @Override public UserDetail getResult(CallableStatement callableStatement, int i) throws SQLException { String string = callableStatement.getString(i); return parseString2UserDetail(string); } /*插入数据 由javabean转换为数据库接收的类型*/} #","link":"/2019/08/11/TypeHander/"}],"tags":[{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"权限管理","slug":"权限管理","link":"/tags/权限管理/"}],"categories":[]}